---
title: "2023"
output: 
  html_document:
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

<<<<<<< HEAD

This will be the rmd for 2023 analysis...
```{r}
library(tidyverse)
library(plotly)
library(ggplot2)
library(gt)
```

```{r}
spotify2023_df = 
  read_csv("spotify-2023.csv") |> 
  janitor::clean_names() |> 
  rename_with(~ gsub("_percent", "", .), contains("_percent")) |> 
  rename(artist = artist_s_name)
view(spotify2023_df)
```
=======
```{r include = FALSE}
library(tidyverse)
library(plotly)
```

# Exploratory Data Analysis
### Discussion of Raw Data

The spotify-2023.csv dataset contains information about the most streamed songs on Spotify in 2023. Each observation includes basic information such as the track name, artist name, release date, and number of streams, as well as additional characteristics like bpm, key, mode, and other audio features. Popularity is measured by presence in Spotify playlists and charts, and across playlists and charts of other streaming platforms including Apple, Deezer, and Shazam.

```{r echo = TRUE, results = 'hide'}
spotify2023_df = 
  read_csv("data/spotify-2023.csv") |> 
  janitor::clean_names() |> 
  rename_with(~ gsub("_percent", "", .), contains("_percent")) |> 
  rename(artist = artist_s_name) |> 
  mutate(streams = ifelse(track_name == "Love Grows (Where My Rosemary Goes)", NA, streams),
         streams = as.numeric(streams))

view(spotify2023_df)
```

### Include issues that come up with data here.

The track "Love Grows" by Edison Lighthouse contained a "streams" observation that was not a numerical value but rather a very long character value and was preventing the aggregation of streaming data. To address this, the value was set as "NA".

The dataset includes the following variables:
- `track_name`: Name of the song.
- `artist`: Name of the artist(s).
- `artist_count`: Number of artists contributing to the song.
- `released_year`: Year the song was released.
- `released_month`: Month the song was released.
- `released_day`: Day of the month the song was released.
- `in_spotify_playlists`: Number of Spotify playlists the song is included in.
- `in_spotify_charts`: Presence and rank of the song on Spotify charts.
- `streams`: Total number of streams on Spotify.
- `in_apple_playlists`: Number of Apple playlists the song is included in.
- `in_apple_charts`: Presence and rank of the song on Apple charts.
- `in_deezer_playlists`: Number of Deezer playlists the song is included in.
- `in_deezer_charts`: Presence and rank of the song on Deezer charts.
- `in_shazam_charts`: Presence and rank of the song on Shazam charts.
- `bpm`: Beats per minute, a measure of song tempo.
- `key`: Key of the song.
- `mode`: Mode of the song (major or minor).
- `danceability`: Percentage indicating how suitable the song is for dancing.
- `valence`: Positivity of the song's musical content.
- `energy`: Perceived energy level of the song.
- `acousticness`: Amount of acoustic sound in the song.
- `instrumentalness`: Amount of instrumental content in the song.
- `liveness`: Presence of live performance elements.
- `speechiness`: Amount of spoken words in the song.

### Summary Data

*Summary Statistics*
```{r}
summary_table = spotify2023_df |> 
  summarize(
    spotify_streams_mean = mean(streams, na.rm = TRUE),
    spotify_streams_median = median(streams, na.rm = TRUE),
    spotify_streams_iqr = IQR(streams, na.rm = TRUE),
    
    spotify_playlists_mean = mean(in_spotify_playlists, na.rm = TRUE),
    spotify_playlists_median = median(in_spotify_playlists, na.rm = TRUE),
    spotify_playlists_iqr = IQR(in_spotify_playlists, na.rm = TRUE),
    
    apple_playlists_mean = mean(in_apple_playlists, na.rm = TRUE),
    apple_playlists_median = median(in_apple_playlists, na.rm = TRUE),
    apple_playlists_iqr = IQR(in_apple_playlists, na.rm = TRUE),
    
    deezer_playlists_mean = mean(in_deezer_playlists, na.rm = TRUE),
    deezer_playlists_median = median(in_deezer_playlists, na.rm = TRUE),
    deezer_playlists_iqr = IQR(in_deezer_playlists, na.rm = TRUE)
  ) |> 
  pivot_longer(
    cols = everything(),
    names_to = c("Platform", "Statistic"),  
    names_pattern = "(.*)_(.*)"
  ) |> 
  mutate(
    Platform = case_when(
      Platform == "spotify_streams" ~ "Spotify Streams",
      Platform == "spotify_playlists" ~ "# of Spotify Playlists",
      Platform == "apple_playlists" ~ "# of Apple Playlists",
      Platform == "deezer_playlists" ~ "# of Deezer Playlists",
      TRUE ~ Platform)
  ) |> 
  pivot_wider(
    names_from = Statistic,               
    values_from = value
  )

summary_table |> 
  gt() |> 
  tab_header(
    title = "Summary Statistics Across Platforms",
    subtitle = "Mean, Median, and Interquartile Range"
  ) |> 
  cols_label(
    Platform = "Platform",
    mean = "Mean",
    median = "Median",
    iqr = "Interquartile Range"
  ) |> 
  fmt_number(
    columns = c(mean, median, iqr),
    decimals = 0
  ) |> 
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels()
  )
```

*Interpretation*
Total number of streams was only available for Spotify and displays a much greater mean than median, indicating a right-skewed distribution. The mean, median, and IQR for number of playlists each song was on are significantly larger for Spotify than Apple and Deezer. This suggests that the total number of playlists on Spotify is much larger than the total number of playlists on Apple or Deezer. The distributions of number of playlists for Spotify, Apple, and Deezer are also right-skewed.

*Top 10 Streamed Songs*
```{r top 10 streams}
top10streamed = spotify2023_df |>
  arrange(desc(streams)) |> 
  slice_head(n = 10)

table_top10streamed = top10streamed |>
  select(track_name, artist, streams) |>
         gt() |>
         tab_header(
           title = "Top 10 Streamed Songs on Spotify in 2024") |>
         fmt_number(
           columns = streams,
           decimals = 0
         ) |>
         cols_label(
           track_name = "Song Title",
           artist = "Artist",
           streams = "Streams"
         )

table_top10streamed
```

*Top 10 Songs by Playlist Count*
```{r top 10 playlist}
top10playlist <- spotify2023_df |>
  mutate(
    cumulative_playlist = rowSums(across(c(in_spotify_playlists, in_apple_playlists, in_deezer_playlists), ~ replace_na(.x, 0)))
  ) |> 
  arrange(desc(cumulative_playlist)) |>
  slice_head(n = 10)

table_top10playlist <- top10playlist |>
  select(track_name, artist, cumulative_playlist) |>
  gt() |>
  tab_header(
    title = "Top 10 Songs By Presence on Playlists",
    subtitle = "Aggregated across Spotify, Apple Music, and Deezer"
  ) |>
  fmt_number(
    columns = cumulative_playlist,
    decimals = 0
  ) |>
  cols_label(
    track_name = "Song Title",
    artist = "Artist",
    cumulative_playlist = "Cumulative Playlist Count"
  )

table_top10playlist
```

*Top 10 Songs by Rank Across Platforms*
```{r top 10 rank}
top10charts <- spotify2023_df |>
  mutate(
    chart_presence_score = rowSums(across(c(in_spotify_charts, in_apple_charts, in_deezer_charts, in_shazam_charts), ~ replace_na(.x, 0)))
  ) |>
  arrange(desc(chart_presence_score)) |>
  slice_head(n = 10)

table_top10charts <- top10charts |>
  select(track_name, artist, chart_presence_score) |>
  gt() |>
  tab_header(
    title = "Top 10 Songs By Chart Presence",
    subtitle = "Aggregated across Spotify, Apple Music, Deezer, and Shazam"
  ) |>
  fmt_number(
    columns = chart_presence_score,
    decimals = 0
  ) |>
  cols_label(
    track_name = "Song Title",
    artist = "Artist",
    chart_presence_score = "Cumulative Chart Presence"
  )

table_top10charts
```

*Top 10 Artists by Total Number of Spotify Streams*
```{r top 10 artist}
top10artists <- spotify2023_df |>
  group_by(artist) |>
  summarise(total_streams = sum(streams, na.rm = TRUE)) |>
  arrange(desc(total_streams)) |>
  slice_head(n = 10)

table_top10artists <- top10artists |>
  gt() |>
  tab_header(
    title = "Top 10 Artists By Total Spotify Streams",
    subtitle = "Based on aggregated stream counts"
  ) |>
  fmt_number(
    columns = total_streams,
    decimals = 0
  ) |>
  cols_label(
    artist = "Artist",
    total_streams = "Total Streams"
  )

table_top10artists
```

*Top 3 Songs by Playlist Count Between Platforms*
```{r}
top3_combined <- bind_rows(
  spotify2023_df |>
    arrange(desc(in_spotify_playlists)) |>
    slice_head(n = 3) |>
    mutate(platform = "Spotify", playlist_count = in_spotify_playlists),
  
  spotify2023_df |>
    arrange(desc(in_apple_playlists)) |>
    slice_head(n = 3) |>
    mutate(platform = "Apple Music", playlist_count = in_apple_playlists),
  
  spotify2023_df |>
    arrange(desc(in_deezer_playlists)) |>
    slice_head(n = 3) |>
    mutate(platform = "Deezer", playlist_count = in_deezer_playlists)
)

table_top3_combined <- top3_combined |>
  select(platform, track_name, artist, playlist_count) |>
  gt() |>
  tab_header(
    title = "Top 3 Songs by Playlist Count Across Platforms",
    subtitle = "Spotify, Apple Music, and Deezer"
  ) |>
  fmt_number(
    columns = playlist_count,
    decimals = 0
  ) |>
  cols_label(
    platform = "Platform",
    track_name = "Song Title",
    artist = "Artist",
    playlist_count = "Playlist Count"
  ) |>
  tab_spanner(
    label = "Playlist Data",
    columns = c(track_name, artist, playlist_count)
  ) |>
  opt_row_striping()

table_top3_combined
```
Assessing popularity through number of playlists a song is included on showed minimal overlap between Spotify, Apple Music, and Deezer. Only top 3 were included for the sake of simplicity in the table. "Get Lucky - Radio Edit" by Pharrell Williams, Nile Rodgers, and Daft Punk is among the top 3 songs by playlist count on both Spotify and Deezer.

### Visualizations

*Spotify Streams by BPM*
```{r}
bpm_streams_df <- spotify2023_df |> 
  filter(streams > 10000000)

bpm_streams_plot <- ggplot(bpm_streams_df, aes(x = bpm, y = streams)) +
  geom_point(aes(color = bpm), size = 3, alpha = 0.7) + 
  scale_y_log10(labels = scales::comma) +           
  scale_color_viridis_c(option = "plasma", end = 0.9) +
  labs(
    title = "BPM vs Spotify Streams",
    subtitle = "Analyzing the relationship between song tempo and popularity",
    x = "Beats Per Minute (BPM)",
    y = "Spotify Streams (log scale)",
    color = "BPM"
  ) +
  theme_minimal(base_size = 15) +       
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    legend.position = "right"
  )

interactive_bpm_streams_plot <- ggplotly(bpm_streams_plot, tooltip = c("x", "y", "color"))

interactive_bpm_streams_plot
```

*Spotify Streams by Key*
```{r}
streams_by_key <- spotify2023_df |>
  filter(!is.na(key)) |>
  group_by(key) |>
  summarise(total_streams = sum(streams, na.rm = TRUE)) |>
  arrange(desc(total_streams))

streams_by_key_plot <- ggplot(streams_by_key, aes(x = reorder(key, total_streams), y = total_streams, fill = key)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) +   
  scale_y_continuous(labels = scales::comma) +                  
  scale_fill_viridis_d(option = "magma", end = 0.9) +           
  labs(
    title = "Total Streams by Musical Key",
    x = "Musical Key",
    y = "Total Streams",
  ) +
  theme_minimal(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    legend.position = "none"
  )

streams_by_key_plot
```

*Spotify Streams by Mode*
```{r}
streams_by_mode <- spotify2023_df |>
  filter(!is.na(mode)) |>
  group_by(mode) |>
  summarise(total_streams = sum(streams, na.rm = TRUE)) |>
  arrange(desc(total_streams))

streams_by_mode_plot <- ggplot(streams_by_mode, aes(x = reorder(mode, total_streams), y = total_streams, fill = mode)) +
  geom_bar(stat = "identity", color = "black", alpha = 0.7) + 
  scale_y_continuous(labels = scales::comma) +               
  scale_fill_viridis_d(option = "magma", end = 0.9) +    
  labs(
    title = "Total Streams by Musical Mode",
    x = "Musical Mode",
    y = "Total Streams"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5),
    plot.subtitle = element_text(size = 14, hjust = 0.5),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    legend.position = "none"
  )

streams_by_mode_plot
```

*Danceability vs. Energy*
```{r}
spotify2023_df$artist <- iconv(spotify2023_df$artist, to = "ASCII", sub = "")
spotify2023_df$track_name <- iconv(spotify2023_df$track_name, to = "ASCII", sub = "")
```

```{r}
p <- ggplot(spotify2023_df, aes(x = danceability, y = energy, color = danceability,
                      text = paste("Track: ", track_name, 
                                   "<br>Artist: ", artist, 
                                   "<br>Danceability: ", round(danceability, 2),
                                   "<br>Energy: ", round(energy, 2)))) +
  geom_point(alpha = 0.7) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Danceability vs Energy",
       x = "Danceability",
       y = "Energy") +
  theme_minimal()

interactive_plot <- ggplotly(p, tooltip = "text")

interactive_plot


```

*Counts of songs by musical key*
```{r}
spotify2023_df$key <- factor(spotify2023_df$key, levels = c("A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"))

levels(spotify2023_df$key)

table(spotify2023_df$key)
```

```{r}
p <- ggplot(spotify2023_df, aes(x = key, fill = key, 
                                text = paste("Track: ", track_name, 
                                             "<br>Key: ", key))) +
  geom_bar(stat = "count") +
  labs(title = "Count of Songs by Musical Key",
       x = "Musical Key",
       y = "Count of Songs") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") 

interactive_plot <- ggplotly(p, tooltip = "text")

interactive_plot
```

*BPM vs Danceability*
```{r}
p <- ggplot(spotify2023_df, aes(x = bpm, fill = "bpm")) +
  geom_density(alpha = 0.5) +
  geom_density(aes(x = danceability, fill = "danceability"), alpha = 0.5) +
  scale_fill_manual(values = c("bpm" = "blue", "danceability" = "red")) +
  labs(title = "Density Plot: BPM vs Danceability",
       x = "Value",
       y = "Density") +
  theme_minimal()

print(p)

```

*Danceability vs. Energy*
```{r}
spotify2023_df$artist <- iconv(spotify2023_df$artist, to = "ASCII", sub = "")
spotify2023_df$track_name <- iconv(spotify2023_df$track_name, to = "ASCII", sub = "")
```

```{r}
p <- ggplot(spotify2023_df, aes(x = danceability, y = energy, color = danceability,
                      text = paste("Track: ", track_name, 
                                   "<br>Artist: ", artist, 
                                   "<br>Danceability: ", round(danceability, 2),
                                   "<br>Energy: ", round(energy, 2)))) +
  geom_point(alpha = 0.7) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Danceability vs Energy",
       x = "Danceability",
       y = "Energy") +
  theme_minimal()

interactive_plot <- ggplotly(p, tooltip = "text")

interactive_plot
```

*Counts of songs by musical key*

```{r}
spotify2023_df$key <- factor(spotify2023_df$key, levels = c("A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"))

levels(spotify2023_df$key)

table(spotify2023_df$key)
```

```{r}
p <- ggplot(spotify2023_df, aes(x = key, fill = key, 
                                text = paste("Track: ", track_name, 
                                             "<br>Key: ", key))) +
  geom_bar(stat = "count") +
  labs(title = "Count of Songs by Musical Key",
       x = "Musical Key",
       y = "Count of Songs") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") 

interactive_plot <- ggplotly(p, tooltip = "text")

interactive_plot
```

*BPM vs Danceability*
```{r}
p <- ggplot(spotify2023_df, aes(x = bpm, fill = "bpm")) +
  geom_density(alpha = 0.5) +
  geom_density(aes(x = danceability, fill = "danceability"), alpha = 0.5) +
  scale_fill_manual(values = c("bpm" = "blue", "danceability" = "red")) +
  labs(title = "Density Plot: BPM vs Danceability",
       x = "Value",
       y = "Density") +
  theme_minimal()

print(p)

```

=======
This will be the rmd for 2023 analysis...
>>>>>>> a7a6440417c688ea335b86a025c3ebb9866b8ef9
>>>>>>> 6073c2d6c98c0b4391fbec86ffc61b5bc33535b3
